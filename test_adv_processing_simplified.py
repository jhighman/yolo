import os
import sys
import json
import logging
import time
from pathlib import Path
from dotenv import load_dotenv

# Add parent directory to Python path
sys.path.append(str(Path(__file__).parent))

# Import the simplified ADV processing agent
from agents.adv_processing_agent_simplified import ADVProcessingAgentSimplified

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(level=logging.INFO, 
                   format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Disable verbose pdfminer logging
logging.getLogger('pdfminer').setLevel(logging.ERROR)

def test_simplified_adv_processing():
    """Test the simplified ADV processing functionality with a real PDF."""
    
    # Initialize the simplified ADV Processing Agent
    adv_agent = ADVProcessingAgentSimplified(cache_dir="cache")
    
    # Test parameters
    subject_id = "test-subject"
    crd_number = "174346"  # Using a smaller 1MB PDF file
    
    # Create cache directory if it doesn't exist
    cache_path = adv_agent.get_cache_path(subject_id, crd_number)
    os.makedirs(cache_path, exist_ok=True)
    
    # Check if the PDF already exists
    pdf_path = os.path.join(cache_path, "adv.pdf")
    if not os.path.exists(pdf_path):
        # Download the ADV PDF
        logger.info(f"Downloading ADV PDF for CRD {crd_number}")
        success, error_message = adv_agent.download_adv_pdf(subject_id, crd_number)
        
        if not success:
            logger.error(f"Failed to download ADV PDF: {error_message}")
            return
    else:
        logger.info(f"Using existing ADV PDF for CRD {crd_number}")
    
    # Extract AUM text only (skip OpenAI API call)
    logger.info("Extracting AUM text only (skipping OpenAI API call)")
    start_time = time.time()
    aum_text = adv_agent.extract_aum_text(pdf_path, max_pages=20)
    extraction_time = time.time() - start_time
    logger.info(f"Text extraction completed in {extraction_time:.2f} seconds")
    
    # Save the extracted text to a file
    text_path = os.path.join(cache_path, "simplified_aum_text.txt")
    with open(text_path, 'w') as f:
        f.write(aum_text)
    logger.info(f"Saved AUM text to {text_path}")
    
    # Create a sample JSON file with the extracted information
    # This would normally be generated by OpenAI, but we're skipping that step
    logger.info("Creating sample AUM info JSON (skipping OpenAI call)")
    
    # Try to extract some basic information using regex
    import re
    aum_info = {
        "reported_aum": "unknown",
        "aum_range": "unknown",
        "as_of_date": "unknown",
        "aum_type": "unknown",
        "source_section": "unknown",
        "compliance_rationale": "unknown",
        "registration_implication": "unknown",
        "update_trigger": "unknown"
    }
    
    # Look for discretionary AUM
    discretionary_match = re.search(r"Discretionary:.*?\$\s*([\d,]+)", aum_text)
    if discretionary_match:
        aum_info["reported_aum"] = f"${discretionary_match.group(1)}"
        aum_info["aum_type"] = "discretionary"
    
    # Look for AUM range
    range_match = re.search(r"\$([\w\s]+) to less than \$([\w\s]+)", aum_text)
    if range_match:
        aum_info["aum_range"] = f"${range_match.group(1)} to less than ${range_match.group(2)}"
    
    # Save the results to a JSON file
    output_path = os.path.join(cache_path, "simplified_aum_info.json")
    with open(output_path, 'w') as f:
        json.dump(aum_info, f, indent=2)
    
    # Print the results
    logger.info(f"AUM information extracted and saved to {output_path}")
    logger.info(f"Reported AUM: {aum_info.get('reported_aum', 'unknown')}")
    logger.info(f"AUM Range: {aum_info.get('aum_range', 'unknown')}")
    logger.info(f"As of Date: {aum_info.get('as_of_date', 'unknown')}")
    logger.info(f"AUM Type: {aum_info.get('aum_type', 'unknown')}")
    
    # Create a file with the prompt that would be sent to OpenAI
    prompt = """
Extract the Assets Under Management (AUM) information from the provided text and return a structured JSON response.

Return your response using this JSON schema:
{
  "reported_aum": "<exact numeric value in USD>",
  "aum_range": "<range if exact value not given>",
  "as_of_date": "<date or 'unknown'>",
  "aum_type": "<'discretionary' | 'non-discretionary' | 'both' | 'unknown'>"
}

Text:
""" + aum_text
    
    prompt_path = os.path.join(cache_path, "simplified_chatgpt_prompt.txt")
    with open(prompt_path, 'w') as f:
        f.write(prompt)
    logger.info(f"Saved ChatGPT prompt to {prompt_path}")
    
    return aum_info

if __name__ == "__main__":
    logger.info("Starting simplified ADV processing test")
    
    # Test the simplified extraction
    start_time = time.time()
    aum_info = test_simplified_adv_processing()
    total_time = time.time() - start_time
    
    logger.info(f"Simplified ADV processing test completed in {total_time:.2f} seconds")